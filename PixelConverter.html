<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Art Converter</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      color: #333;
      line-height: 1.6;
    }

    .container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #fff;
      border-right: 1px solid #ddd;
      min-height: 0;
      overflow: hidden;
    }

    .toolbar {
      padding: 16px 20px;
      background: #fafafa;
      border-bottom: 1px solid #ddd;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar-group label {
      font-size: 13px;
      font-weight: 500;
      color: #666;
      margin: 0;
    }

    .canvas-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
      padding: 20px;
      background: #fafafa;
      position: relative;
      min-height: 0;
    }

    .canvas-wrapper::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .canvas-wrapper::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .canvas-wrapper::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    .canvas-wrapper::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .canvas-wrapper.drag-over {
      background: #e3f2fd;
      border: 3px dashed #2196F3;
    }

    .drop-zone {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .canvas-wrapper.drag-over .drop-zone {
      opacity: 1;
    }

    .drop-zone-icon {
      font-size: 64px;
      color: #2196F3;
      margin-bottom: 16px;
    }

    .drop-zone-text {
      font-size: 18px;
      font-weight: 500;
      color: #2196F3;
    }

    .canvas-container {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      border: 2px solid #333;
      image-rendering: pixelated;
      cursor: crosshair;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      background: white;
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }

    .sidebar {
      width: 380px;
      background: #fff;
      overflow-y: auto;
      padding: 20px;
      border-left: 1px solid #ddd;
    }

    .sidebar h3 {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin: 20px 0 12px 0;
      padding-bottom: 8px;
      border-bottom: 2px solid #e0e0e0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar h3:first-child {
      margin-top: 0;
    }

    .panel {
      width: 100%;
    }

    .group {
      cursor: pointer;
      padding: 10px 12px;
      margin: 4px 0;
      border-radius: 6px;
      background: #f9f9f9;
      border: 2px solid transparent;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .group:hover {
      background: #f0f0f0;
      border-color: #ddd;
    }

    .group.active {
      background: #e3f2fd;
      border-color: #2196F3;
      font-weight: 500;
    }

    .color-box {
      width: 20px;
      height: 20px;
      display: inline-block;
      border-radius: 4px;
      border: 1px solid #ddd;
      flex-shrink: 0;
    }

    textarea {
      width: 100%;
      height: 180px;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      resize: vertical;
      background: #fafafa;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      font-weight: 500;
      color: #666;
    }

    input[type="number"],
    input[type="file"],
    select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 13px;
      background: white;
      transition: border-color 0.2s;
    }

    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: #2196F3;
    }

    input[type="color"] {
      width: 40px;
      height: 40px;
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      margin: 4px;
    }

    input[type="range"] {
      width: 150px;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #2196F3;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #2196F3;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0;
    }

    .btn {
      padding: 10px 16px;
      cursor: pointer;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
    }

    .btn:hover {
      background: #1976D2;
      box-shadow: 0 4px 8px rgba(33, 150, 243, 0.4);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
    }

    .btn-secondary {
      background: #757575;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .btn-secondary:hover {
      background: #616161;
    }

    .hint {
      font-size: 11px;
      color: #666;
      line-height: 1.4;
      background: #f9f9f9;
      padding: 8px 12px;
      border-radius: 6px;
      border-left: 3px solid #2196F3;
      margin: 0;
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: auto;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      max-width: 600px;
      transition: all 0.3s ease;
    }

    .hint.collapsed {
      max-width: 48px;
      padding: 8px;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hint.collapsed .hint-header {
      padding: 0;
    }

    .hint.collapsed .hint-title {
      display: none;
    }

    .hint.collapsed .hint-toggle {
      font-size: 20px;
    }

    .hint b {
      color: #333;
      font-size: 11px;
    }

    .hint-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
      padding: 4px 0;
      gap: 8px;
    }

    .hint-title {
      font-weight: 600;
      color: #2196F3;
      font-size: 12px;
      white-space: nowrap;
    }

    .hint-toggle {
      background: none;
      border: none;
      color: #2196F3;
      cursor: pointer;
      font-size: 16px;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .hint-toggle:hover {
      background: #e3f2fd;
    }

    .hint-content {
      max-height: 200px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .hint-content.collapsed {
      max-height: 0;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    input.group-name {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 13px;
      background: white;
    }

    input.group-name:focus {
      outline: none;
      border-color: #2196F3;
    }

    #palette {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin: 8px 0;
    }

    .stats-item {
      padding: 8px 12px;
      background: #f9f9f9;
      border-radius: 6px;
      margin: 4px 0;
      font-size: 13px;
    }

    .validation {
      margin-top: 8px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
    }

    .validation.success {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .validation.error {
      background: #ffebee;
      color: #c62828;
    }

    #paintControls,
    #eraseControls {
      background: #f9f9f9;
      padding: 12px;
      border-radius: 6px;
      margin: 8px 0;
    }

    .zoom-display {
      font-size: 13px;
      color: #666;
      min-width: 50px;
      text-align: center;
      font-weight: 500;
    }
  </style>
</head>

<body>

  <div class="container">
    <!-- Canvas Area -->
    <div class="canvas-area">
      <div class="toolbar">
        <div class="toolbar-group">
          <label>Target Size:</label>
          <input type="number" id="sizeInput" value="64" min="8" max="256" style="width:70px">
        </div>

        <div class="toolbar-group">
          <label>Scale Mode:</label>
          <select id="scaleMode">
            <option value="majority" selected>Block Majority</option>
            <option value="nearest">Nearest Neighbor</option>
          </select>
        </div>

        <div class="toolbar-group">
          <label>Edit Mode:</label>
          <select id="editMode">
            <option value="group" selected>Group Data</option>
            <option value="colorType">Color Type</option>
            <option value="paint">Paint Pixel</option>
            <option value="erase">Erase Pixel</option>
          </select>
        </div>

        <div class="toolbar-group">
          <label>Zoom:</label>
          <input type="range" id="zoomSlider" min="1" max="20" value="10" step="0.5">
          <span class="zoom-display" id="zoomDisplay">100%</span>
        </div>

        <div class="toolbar-group">
          <input type="file" id="upload">
        </div>

        <div class="toolbar-group">
          <button class="btn btn-secondary" id="undoBtn">‚Ü∂ Undo</button>
        </div>
      </div>

      <div id="paintControls"
        style="display:none; padding: 12px 20px; background: #fff3cd; border-bottom: 1px solid #ddd;">
        <div style="display: flex; align-items: center; gap: 12px;">
          <label style="margin: 0;">Paint Color:</label>
          <input type="color" id="paintColor" value="#FF0000">
          <button class="btn" id="applyPaint">Apply to Selected</button>
          <button class="btn btn-secondary" id="deselectPaint">Deselect All</button>
        </div>
      </div>

      <div id="eraseControls"
        style="display:none; padding: 12px 20px; background: #f8d7da; border-bottom: 1px solid #ddd;">
        <div style="display: flex; align-items: center; gap: 12px;">
          <button class="btn" id="applyErase">Erase Selected</button>
          <button class="btn btn-secondary" id="deselectErase">Deselect All</button>
        </div>
      </div>

      <div class="canvas-wrapper" id="canvasWrapper">
        <div class="drop-zone">
          <div class="drop-zone-icon">üìÅ</div>
          <div class="drop-zone-text">Drop image here</div>
        </div>
        <div class="canvas-container">
          <canvas id="canvas" width="640" height="640"></canvas>
        </div>
      </div>

      <div class="hint">
        <div class="hint-header" onclick="toggleHint()">
          <span class="hint-title">üí° Instructions</span>
          <button class="hint-toggle" id="hintToggle">üí°</button>
        </div>
        <div class="hint-content" id="hintContent">
          <div style="margin-top: 8px;">
            <b>Modes:</b> Group Data ‚Ä¢ Color Type ‚Ä¢ Paint ‚Ä¢ Erase<br>
            <b>Group Data:</b> Drag rectangle to assign pixels to data groups<br>
            <b>Color Type:</b> Drag rectangle to assign pixels to color type groups<br>
            <b>Paint:</b> Select pixels ‚Üí choose color ‚Üí apply<br>
            <b>Erase:</b> Select pixels ‚Üí erase<br>
            <b>Color Filter:</b> Click color in "Group Color" to filter operations<br>
            <b>Shortcuts:</b> Ctrl+Z (undo) ‚Ä¢ Ctrl+V (paste image)
          </div>
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <div class="panel">
        <h3>Palette</h3>
        <div id="palette"></div>
        <button class="btn" id="addColor">+ Add Color</button>

        <h3>Group Color</h3>
        <div id="colorGroups"></div>

        <h3>Group Color Type & Statistics</h3>
        <button class="btn" id="parseColorType">Parse from Group Color</button>
        <div id="colorTypeGroups"></div>

        <h3>Group Data</h3>
        <div class="row">
          <button class="btn" id="addDataGroup">Add</button>
          <button class="btn btn-secondary" id="deleteDataGroup">Delete</button>
          <button class="btn btn-secondary" id="clearDataGroup">Clear</button>
        </div>
        <div id="dataGroups"></div>

        <h3>Export / Import</h3>
        <div class="row">
          <button class="btn" id="exportBtn">Export JSON</button>
          <button class="btn" id="exportPngBtn">Export PNG</button>
          <button class="btn btn-secondary" id="importBtn">Import JSON</button>
        </div>
        <input type="file" id="importFile" accept=".json" style="display:none">
        <textarea id="output" placeholder="JSON output will appear here..."></textarea>
      </div>
    </div>
  </div>

  <script>
    /* ================= CONFIG ================= */
    let SIZE = 64;
    const ALPHA_CUTOFF = 10;
    let ZOOM_SCALE = 10; // Default zoom scale

    /* ================= CANVAS ================= */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    /* ================= STATE ================= */
    let pixels = [];
    let palette = [];
    let groups = [];
    let activeColorGroup = -1;
    let selectedPixels = new Set(); // For paint/erase mode selection
    let undoStack = []; // For undo functionality
    const MAX_UNDO = 50;

    let dataGroups = [{ id: 0, name: 'None' }];
    let activeDataGroupId = 0;

    // NEW: Color Type system
    let colorTypeGroups = []; // Stores color type groups
    let activeColorTypeId = 0;

    let originalImage = null;

    // drag state
    let isDragging = false;
    let dragStart = null;
    let dragEnd = null;

    /* ================= PRESET PALETTE ================= */
    const PRESET = [
      '#FFFFFF', '#000000', '#FFD700', '#00C853',
      '#2196F3', '#F48FB1', '#E53935', '#8E24AA', '#FB8C00'
    ];

    function initPalette() {
      const p = document.getElementById('palette');
      p.innerHTML = '';
      palette = [];
      PRESET.forEach(addColor);
    }

    function addColor(hex = '#888888') {
      const i = document.createElement('input');
      i.type = 'color';
      i.value = hex;
      i.onchange = regroup;
      palette.push(i);
      document.getElementById('palette').append(i, document.createElement('br'));
    }

    // keep original structure (just fix handler target)
    document.getElementById('addColor').onclick = () => { addColor(); regroup(); };

    /* ================= LOAD IMAGE ================= */
    function loadImage(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }

      const img = new Image();
      img.onload = () => {
        originalImage = img;
        convert(img);
      };
      img.src = URL.createObjectURL(file);
    }

    document.getElementById('upload').onchange = e => {
      if (e.target.files[0]) {
        loadImage(e.target.files[0]);
      }
    };

    // Drag and drop functionality
    const canvasWrapper = document.getElementById('canvasWrapper');

    canvasWrapper.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      canvasWrapper.classList.add('drag-over');
    });

    canvasWrapper.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      canvasWrapper.classList.remove('drag-over');
    });

    canvasWrapper.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      canvasWrapper.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        loadImage(files[0]);
      }
    });

    // Prevent default drag behavior on document
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
    });

    document.getElementById('sizeInput').onchange =
      document.getElementById('scaleMode').onchange = () => {
        if (originalImage) convert(originalImage);
      };

    // Zoom slider
    document.getElementById('zoomSlider').oninput = (e) => {
      ZOOM_SCALE = parseFloat(e.target.value);
      const percentage = Math.round((ZOOM_SCALE / 10) * 100);
      document.getElementById('zoomDisplay').textContent = percentage + '%';

      // Update canvas size and redraw
      const oldWidth = canvas.width;
      updateCanvasSize();

      // Redraw the image at new size if we have pixels
      if (pixels.length > 0) {
        // Create temporary canvas with pixel data
        const t = document.createElement('canvas');
        t.width = SIZE;
        t.height = SIZE;
        const tctx = t.getContext('2d');
        const imgData = tctx.createImageData(SIZE, SIZE);
        const data = imgData.data;

        // Fill with transparent background
        for (let i = 0; i < data.length; i += 4) {
          data[i + 3] = 0;
        }

        // Draw pixels
        pixels.forEach(p => {
          const i = (p.y * SIZE + p.x) * 4;
          data[i] = p.r;
          data[i + 1] = p.g;
          data[i + 2] = p.b;
          data[i + 3] = 255;
        });

        tctx.putImageData(imgData, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(t, 0, 0, canvas.width, canvas.height);
      }

      draw();
    };

    function updateCanvasSize() {
      const disp = SIZE * ZOOM_SCALE;
      canvas.width = disp;
      canvas.height = disp;
    }

    /* ================= CONVERT (BLOCK MAJORITY + TRANSPARENT FIX) ================= */
    function convert(img) {
      SIZE = parseInt(document.getElementById('sizeInput').value) || 64;
      const mode = document.getElementById('scaleMode').value;

      const src = document.createElement('canvas');
      src.width = img.width;
      src.height = img.height;
      const sctx = src.getContext('2d');
      sctx.drawImage(img, 0, 0);

      const srcData = sctx.getImageData(0, 0, img.width, img.height).data;

      const t = document.createElement('canvas');
      t.width = SIZE;
      t.height = SIZE;
      const tctx = t.getContext('2d');

      const dstImg = tctx.createImageData(SIZE, SIZE);
      const dst = dstImg.data;

      const sx = img.width / SIZE;
      const sy = img.height / SIZE;

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const di = (y * SIZE + x) * 4;

          if (mode === 'nearest') {
            const px = Math.floor(x * sx);
            const py = Math.floor(y * sy);
            const si = (py * img.width + px) * 4;
            dst.set(srcData.slice(si, si + 4), di);
            continue;
          }

          const x0 = Math.floor(x * sx), x1 = Math.floor((x + 1) * sx);
          const y0 = Math.floor(y * sy), y1 = Math.floor((y + 1) * sy);

          const map = new Map();
          for (let yy = y0; yy < y1; yy++) for (let xx = x0; xx < x1; xx++) {
            const si = (yy * img.width + xx) * 4;
            if (srcData[si + 3] < ALPHA_CUTOFF) continue;
            const r = srcData[si] >> 3;
            const g = srcData[si + 1] >> 3;
            const b = srcData[si + 2] >> 3;
            const key = (r << 10) | (g << 5) | b;
            map.set(key, (map.get(key) || 0) + 1);
          }

          if (map.size === 0) {
            dst[di + 3] = 0;
            continue;
          }

          let bestKey = 0, max = 0;
          for (const [k, v] of map) if (v > max) { max = v; bestKey = k; }

          dst[di] = ((bestKey >> 10) & 31) << 3;
          dst[di + 1] = ((bestKey >> 5) & 31) << 3;
          dst[di + 2] = (bestKey & 31) << 3;
          dst[di + 3] = 255;
        }
      }

      tctx.putImageData(dstImg, 0, 0);
      updateCanvasSize();
      ctx.drawImage(t, 0, 0, canvas.width, canvas.height);

      readPixels(tctx);
      regroup();
      draw();
    }

    /* ================= PIXELS ================= */
    function readPixels(tctx) {
      pixels = [];
      const d = tctx.getImageData(0, 0, SIZE, SIZE).data;
      for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) {
        const i = (y * SIZE + x) * 4;
        if (d[i + 3] < ALPHA_CUTOFF) continue;
        pixels.push({ x, y, r: d[i], g: d[i + 1], b: d[i + 2], group: 0, colorGroup: -1, colorType: 0 });
      }
    }

    /* ================= GROUP COLOR ================= */
    function colorDistance(p, c) {
      return (p.r - c.r) ** 2 + (p.g - c.g) ** 2 + (p.b - c.b) ** 2;
    }

    function regroup() {
      groups = palette.map((p, i) => ({ index: i, color: hexToRgb(p.value), pixels: [] }));
      pixels.forEach(px => {
        let best = 0, min = colorDistance(px, groups[0].color);
        for (let i = 1; i < groups.length; i++) {
          const d = colorDistance(px, groups[i].color);
          if (d < min) { min = d; best = i; }
        }
        px.colorGroup = best;
        groups[best].pixels.push(px);
      });
      renderColorGroups();
      renderDataGroups();
      renderColorTypeGroups();
    }

    /* ================= DRAW ================= */
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const s = canvas.width / SIZE;

      pixels.forEach(p => {
        ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
        ctx.fillRect(p.x * s, p.y * s, s, s);

        // Green highlight for selected pixels in paint mode
        const pixelKey = `${p.x},${p.y}`;
        if (selectedPixels.has(pixelKey)) {
          ctx.strokeStyle = 'rgba(0,255,0,0.9)';
          ctx.lineWidth = 2;
          ctx.strokeRect(p.x * s + 1, p.y * s + 1, s - 2, s - 2);
        }

        // Blue highlight for color group selection
        if (activeColorGroup >= 0 && p.colorGroup === activeColorGroup) {
          ctx.strokeStyle = 'rgba(0,120,255,0.9)';
          ctx.strokeRect(p.x * s + 1.5, p.y * s + 1.5, s - 3, s - 3);
        }

        // Purple highlight for color type (overrides color group)
        if (activeColorTypeId !== 0 && p.colorType === activeColorTypeId) {
          ctx.strokeStyle = 'rgba(147,51,234,0.9)';
          ctx.lineWidth = 2;
          ctx.strokeRect(p.x * s + 1, p.y * s + 1, s - 2, s - 2);
        }

        // Red highlight for data group (overrides on top)
        if (activeDataGroupId !== 0 && p.group === activeDataGroupId) {
          ctx.strokeStyle = 'red';
          ctx.strokeRect(p.x * s + 0.5, p.y * s + 0.5, s - 1, s - 1);
        }
      });

      if (isDragging && dragStart && dragEnd) {
        const x = Math.min(dragStart.x, dragEnd.x);
        const y = Math.min(dragStart.y, dragEnd.y);
        const w = Math.abs(dragStart.x - dragEnd.x);
        const h = Math.abs(dragStart.y - dragEnd.y);
        ctx.save();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = 'rgba(0,120,255,0.8)';
        ctx.strokeRect(x, y, w, h);
        ctx.restore();
      }
    }

    /* ================= UNDO SYSTEM ================= */
    function saveState() {
      // Deep clone pixels array
      const state = {
        pixels: pixels.map(p => ({ ...p })),
        palette: palette.map(p => p.value),
        dataGroups: dataGroups.map(g => ({ ...g })),
        colorTypeGroups: colorTypeGroups.map(ct => ({ ...ct }))
      };
      undoStack.push(state);
      if (undoStack.length > MAX_UNDO) {
        undoStack.shift();
      }
    }

    function undo() {
      if (undoStack.length === 0) {
        alert('Nothing to undo');
        return;
      }

      const state = undoStack.pop();

      // Restore pixels
      pixels = state.pixels.map(p => ({ ...p }));

      // Restore palette
      palette = [];
      document.getElementById('palette').innerHTML = '';
      state.palette.forEach(colorHex => {
        addColor(colorHex);
      });

      // Restore data groups
      dataGroups = state.dataGroups.map(g => ({ ...g }));

      // Restore color type groups
      colorTypeGroups = state.colorTypeGroups.map(ct => ({ ...ct }));

      // Update everything
      groups = palette.map((p, i) => ({
        index: i,
        color: hexToRgb(p.value),
        pixels: pixels.filter(px => px.colorGroup === i)
      }));

      renderColorGroups();
      renderColorTypeGroups();
      renderDataGroups();
      renderColorTypeGroups();
      draw();
    }

    document.getElementById('undoBtn').onclick = undo;

    // Keyboard shortcut for undo
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
      }
    });
    function canvasPoint(e) {
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    function getPixel(x, y) {
      return pixels.find(p => p.x === x && p.y === y) || null;
    }

    function togglePixelGroup(p) {
      if (!p) return;
      p.group = (p.group === activeDataGroupId) ? 0 : activeDataGroupId;
    }

    function togglePixelColorType(p) {
      if (!p) return;
      p.colorType = (p.colorType === activeColorTypeId) ? 0 : activeColorTypeId;
    }

    function selectPixelsInRect(x0, y0, x1, y1) {
      const minX = Math.min(x0, x1);
      const minY = Math.min(y0, y1);
      const maxX = Math.max(x0, x1);
      const maxY = Math.max(y0, y1);

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const p = getPixel(x, y);
          if (!p) continue;

          // Apply color filter if a color is selected
          if (activeColorGroup >= 0 && p.colorGroup !== activeColorGroup) continue;

          const key = `${x},${y}`;
          if (!selectedPixels.has(key)) {
            selectedPixels.add(key);
            // Update color picker to show the first pixel's color
            if (selectedPixels.size === 1) {
              document.getElementById('paintColor').value = rgbToHex(p.r, p.g, p.b);
            }
          }
        }
      }
    }

    function erasePixelsInRect(x0, y0, x1, y1) {
      const minX = Math.min(x0, x1);
      const minY = Math.min(y0, y1);
      const maxX = Math.max(x0, x1);
      const maxY = Math.max(x0, x1);

      const toRemove = [];
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const p = getPixel(x, y);
          if (!p) continue;

          // Apply color filter if a color is selected
          if (activeColorGroup >= 0 && p.colorGroup !== activeColorGroup) continue;

          toRemove.push(p);
        }
      }

      // Remove pixels
      toRemove.forEach(p => {
        const index = pixels.indexOf(p);
        if (index >= 0) pixels.splice(index, 1);
      });

      if (toRemove.length > 0) {
        // Update groups
        groups = palette.map((p, i) => ({
          index: i,
          color: hexToRgb(p.value),
          pixels: pixels.filter(px => px.colorGroup === i)
        }));
        renderColorTypeGroups();
      }
    }

    function erasePixel(x, y) {
      const index = pixels.findIndex(p => p.x === x && p.y === y);
      if (index >= 0) {
        pixels.splice(index, 1);

        // Update groups
        groups = palette.map((p, i) => ({
          index: i,
          color: hexToRgb(p.value),
          pixels: pixels.filter(px => px.colorGroup === i)
        }));
        renderColorTypeGroups();
      }
    }

    // Show/hide controls based on mode
    document.getElementById('editMode').onchange = (e) => {
      const mode = e.target.value;
      document.getElementById('paintControls').style.display = mode === 'paint' ? 'block' : 'none';
      document.getElementById('eraseControls').style.display = mode === 'erase' ? 'block' : 'none';
      selectedPixels.clear();

      // Deselect groups when switching modes
      if (mode !== 'group') {
        activeDataGroupId = 0;
        renderDataGroups();
      }
      if (mode !== 'colorType') {
        activeColorTypeId = 0;
        renderColorTypeGroups();
      }

      draw();
    };

    // Deselect buttons
    document.getElementById('deselectPaint').onclick = () => {
      selectedPixels.clear();
      draw();
    };

    document.getElementById('deselectErase').onclick = () => {
      selectedPixels.clear();
      draw();
    };

    // Apply paint color to selected pixels
    document.getElementById('applyPaint').onclick = () => {
      const count = selectedPixels.size;
      if (count === 0) {
        alert('No pixels selected. Drag a rectangle on the canvas to select pixels first.');
        return;
      }

      saveState(); // Save for undo

      const colorHex = document.getElementById('paintColor').value;
      const rgb = hexToRgb(colorHex);

      // Find or create color group for this color
      let colorGroupIndex = -1;
      for (let i = 0; i < palette.length; i++) {
        if (palette[i].value.toLowerCase() === colorHex.toLowerCase()) {
          colorGroupIndex = i;
          break;
        }
      }

      // If color not in palette, add it
      if (colorGroupIndex === -1) {
        addColor(colorHex);
        colorGroupIndex = palette.length - 1;
      }

      // Apply color to selected pixels
      selectedPixels.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        const p = getPixel(x, y);
        if (p) {
          p.r = rgb.r;
          p.g = rgb.g;
          p.b = rgb.b;
          p.colorGroup = colorGroupIndex;
        }
      });

      // Clear selection
      selectedPixels.clear();

      // Update groups and UI
      groups = palette.map((p, i) => ({
        index: i,
        color: hexToRgb(p.value),
        pixels: pixels.filter(px => px.colorGroup === i)
      }));

      renderColorGroups();
      renderColorTypeGroups();
      draw();
    };

    // Erase selected pixels
    document.getElementById('applyErase').onclick = () => {
      const count = selectedPixels.size;
      if (count === 0) {
        alert('No pixels selected. Drag a rectangle on the canvas to select pixels first.');
        return;
      }

      saveState(); // Save for undo

      // Remove selected pixels
      selectedPixels.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        const index = pixels.findIndex(p => p.x === x && p.y === y);
        if (index >= 0) {
          pixels.splice(index, 1);
        }
      });

      // Clear selection
      selectedPixels.clear();

      // Update groups and UI
      groups = palette.map((p, i) => ({
        index: i,
        color: hexToRgb(p.value),
        pixels: pixels.filter(px => px.colorGroup === i)
      }));

      renderColorGroups();
      renderColorTypeGroups();
      draw();
    };

    canvas.onmousedown = e => {
      const mode = document.getElementById('editMode').value;
      const pt = canvasPoint(e);

      if (mode === 'paint') {
        isDragging = true;
        dragStart = pt;
        dragEnd = pt;
      } else if (mode === 'erase') {
        isDragging = true;
        dragStart = pt;
        dragEnd = pt;
      } else if (mode === 'colorType') {
        if (activeColorTypeId === 0) return;
        isDragging = true;
        dragStart = pt;
        dragEnd = pt;
      } else if (mode === 'group') {
        if (activeDataGroupId === 0) return;
        isDragging = true;
        dragStart = pt;
        dragEnd = pt;
      }
    };

    canvas.onmousemove = e => {
      if (!isDragging) return;

      const mode = document.getElementById('editMode').value;
      const pt = canvasPoint(e);
      dragEnd = pt;
      draw();
    };

    canvas.onmouseup = () => {
      if (!isDragging) return;

      const mode = document.getElementById('editMode').value;
      const s = canvas.width / SIZE;

      const xStart = Math.floor(dragStart.x / s);
      const yStart = Math.floor(dragStart.y / s);
      const xEnd = Math.floor(dragEnd.x / s);
      const yEnd = Math.floor(dragEnd.y / s);

      const x0 = Math.min(xStart, xEnd);
      const y0 = Math.min(yStart, yEnd);
      const x1 = Math.max(xStart, xEnd);
      const y1 = Math.max(yStart, yEnd);

      if (mode === 'paint') {
        selectPixelsInRect(x0, y0, x1, y1);
      } else if (mode === 'erase') {
        selectPixelsInRect(x0, y0, x1, y1);
      } else if (mode === 'colorType') {
        saveState(); // Save for undo
        for (let y = y0; y <= y1; y++) {
          for (let x = x0; x <= x1; x++) {
            const p = getPixel(x, y);
            if (!p) continue;

            // Apply color filter if a color is selected
            if (activeColorGroup >= 0 && p.colorGroup !== activeColorGroup) continue;

            togglePixelColorType(p);
          }
        }
        renderColorTypeGroups();
      } else if (mode === 'group') {
        for (let y = y0; y <= y1; y++) {
          for (let x = x0; x <= x1; x++) {
            const p = getPixel(x, y);
            if (!p) continue;

            // Apply color filter if a color is selected
            if (activeColorGroup >= 0 && p.colorGroup !== activeColorGroup) continue;

            togglePixelGroup(p);
          }
        }
      }

      isDragging = false;
      dragStart = dragEnd = null;
      draw();
    };

    canvas.onmouseleave = () => {
      if (!isDragging) return;
      isDragging = false;
      dragStart = dragEnd = null;
      draw();
    };

    /* ================= UI ================= */
    function renderColorGroups() {
      const g = document.getElementById('colorGroups');
      g.innerHTML = '';
      groups.forEach(gr => {
        const d = document.createElement('div');
        d.className = 'group' + (gr.index === activeColorGroup ? ' active' : '');
        d.innerHTML = `<span class="color-box" style="background:${palette[gr.index].value}"></span>
      Color ${gr.index}: ${gr.pixels.length}px`;
        d.onclick = () => {
          activeColorGroup = activeColorGroup === gr.index ? -1 : gr.index;
          draw();
          renderColorGroups();
        };
        g.appendChild(d);
      });
    }

    function renderColorTypeGroups() {
      const g = document.getElementById('colorTypeGroups');
      g.innerHTML = '';

      const total = pixels.length;

      // Show statistics header
      const headerDiv = document.createElement('div');
      headerDiv.style.margin = '8px 0';
      headerDiv.innerHTML = `<b>Total pixels:</b> ${total}`;
      g.appendChild(headerDiv);

      // Show color type groups with statistics
      if (colorTypeGroups.length > 0) {
        let typeSum = 0;

        colorTypeGroups.forEach(ct => {
          const count = pixels.filter(p => p.colorType === ct.id).length;
          typeSum += count;

          const d = document.createElement('div');
          d.className = 'group' + (ct.id === activeColorTypeId ? ' active' : '');
          d.innerHTML = `<span class="color-box" style="background:${ct.color}"></span>
      Type ${ct.id}: ${count}px`;
          d.onclick = () => {
            activeColorTypeId = activeColorTypeId === ct.id ? 0 : ct.id;

            // Auto-switch to Color Type mode when selecting a color type
            if (activeColorTypeId !== 0) {
              document.getElementById('editMode').value = 'colorType';
              // Trigger change event to update UI
              document.getElementById('editMode').dispatchEvent(new Event('change'));
            }

            draw();
            renderColorTypeGroups();
          };
          g.appendChild(d);
        });

        // Show "No Type" pixels
        const noType = pixels.filter(p => !p.colorType || p.colorType === 0).length;
        if (noType > 0) {
          const d = document.createElement('div');
          d.className = 'group';
          d.innerHTML = `<span class="color-box" style="background:#ccc"></span>
      No Type: ${noType}px`;
          g.appendChild(d);
          typeSum += noType;
        }

        // Validation message
        const validDiv = document.createElement('div');
        validDiv.style.marginTop = '6px';
        if (typeSum === total) {
          validDiv.style.color = 'green';
          validDiv.innerHTML = '‚úì Type sum matches total';
        } else {
          validDiv.style.color = 'red';
          validDiv.innerHTML = `‚ö† Mismatch ${typeSum} ‚â† ${total}`;
        }
        g.appendChild(validDiv);
      } else {
        // No color types yet
        const d = document.createElement('div');
        d.style.opacity = '0.6';
        d.style.marginTop = '8px';
        d.innerHTML = 'No color types defined. Click "Parse from Group Color" to create them.';
        g.appendChild(d);
      }
    }

    // Parse color types from current group colors
    document.getElementById('parseColorType').onclick = () => {
      saveState(); // Save for undo

      colorTypeGroups = [];
      groups.forEach((gr, index) => {
        if (gr.pixels.length > 0) {
          colorTypeGroups.push({
            id: index + 1,
            color: palette[index].value,
            name: `Type ${index + 1}`
          });

          // Assign color type to pixels based on their color group
          gr.pixels.forEach(p => {
            p.colorType = index + 1;
          });
        }
      });

      activeColorTypeId = 0;
      renderColorTypeGroups();
      draw();

      alert(`Created ${colorTypeGroups.length} color type groups from group colors`);
    };

    function renderDataGroups() {
      const g = document.getElementById('dataGroups');
      g.innerHTML = '';
      dataGroups.forEach(gr => {
        const d = document.createElement('div');
        d.className = 'group' + (gr.id === activeDataGroupId ? ' active' : '');

        const input = document.createElement('input');
        input.className = 'group-name';
        input.value = gr.name;

        // ‚úÖ FIX: stop input events from selecting group + rerender
        input.onclick = (e) => e.stopPropagation();
        input.onmousedown = (e) => e.stopPropagation();

        // optional UX: Enter commit, Escape revert
        input.onkeydown = (e) => {
          if (e.key === 'Enter') input.blur();
          if (e.key === 'Escape') { input.value = gr.name; input.blur(); }
        };

        input.onchange = () => {
          gr.name = input.value.trim() || `Group ${gr.id}`;
          input.value = gr.name;
        };

        d.onclick = () => {
          activeDataGroupId = gr.id;

          // Auto-switch to Group Data mode when selecting a data group
          if (activeDataGroupId !== 0) {
            document.getElementById('editMode').value = 'group';
            // Trigger change event to update UI
            document.getElementById('editMode').dispatchEvent(new Event('change'));
          }

          renderDataGroups();
          draw();
        };

        d.appendChild(input);
        g.appendChild(d);
      });
    }

    function nextGroupId() {
      const used = new Set(dataGroups.map(g => g.id));
      let i = 1; while (used.has(i)) i++; return i;
    }

    document.getElementById('addDataGroup').onclick = () => {
      saveState(); // Save for undo
      const id = nextGroupId();
      dataGroups.push({ id, name: `Group ${id}` });
      activeDataGroupId = id;
      renderDataGroups();
      draw();
    };

    document.getElementById('deleteDataGroup').onclick = () => {
      if (activeDataGroupId === 0) return;
      saveState(); // Save for undo
      pixels.forEach(p => { if (p.group === activeDataGroupId) p.group = 0; });
      dataGroups = dataGroups.filter(g => g.id !== activeDataGroupId);
      activeDataGroupId = 0;
      renderDataGroups();
      draw();
    };

    document.getElementById('clearDataGroup').onclick = () => {
      if (activeDataGroupId === 0) return;
      saveState(); // Save for undo
      pixels.forEach(p => { if (p.group === activeDataGroupId) p.group = 0; });
      draw();
    };

    /* ================= EXPORT / IMPORT ================= */
    document.getElementById('exportBtn').onclick = () => {
      const jsonData = {
        Palette: palette.map(p => p.value.slice(1)), // Store palette colors without #
        Artwork: {
          Width: SIZE, Height: SIZE,
          PixelData: pixels.map(p => ({
            Position: { x: p.x, y: p.y },
            Group: p.group,
            ColorGroup: p.colorGroup, // Store the color group index
            ColorType: p.colorType || 0, // Store the color type
            ColorHex: rgbToHex(p.r, p.g, p.b).slice(1)
          }))
        }
      };

      // Display in textarea
      document.getElementById('output').value = JSON.stringify(jsonData, null, 2);

      // Download as file
      const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `pixel_art_${SIZE}x${SIZE}_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    document.getElementById('exportPngBtn').onclick = () => {
      // Create a clean canvas with just the pixel art (no overlays)
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = SIZE;
      exportCanvas.height = SIZE;
      const exportCtx = exportCanvas.getContext('2d');

      // Create image data
      const imgData = exportCtx.createImageData(SIZE, SIZE);
      const data = imgData.data;

      // Fill with transparent background
      for (let i = 0; i < data.length; i += 4) {
        data[i + 3] = 0; // transparent
      }

      // Draw pixels
      pixels.forEach(p => {
        const i = (p.y * SIZE + p.x) * 4;
        data[i] = p.r;
        data[i + 1] = p.g;
        data[i + 2] = p.b;
        data[i + 3] = 255;
      });

      exportCtx.putImageData(imgData, 0, 0);

      // Convert to PNG and download
      exportCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `pixel_art_${SIZE}x${SIZE}_${Date.now()}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };

    document.getElementById('importBtn').onclick = () => {
      document.getElementById('importFile').click();
    };

    document.getElementById('importFile').onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const jsonData = JSON.parse(event.target.result);

          // Validate structure
          if (!jsonData.Artwork || !jsonData.Artwork.PixelData) {
            alert('Invalid JSON format: Missing Artwork or PixelData');
            return;
          }

          // Import size
          SIZE = jsonData.Artwork.Width || SIZE;
          document.getElementById('sizeInput').value = SIZE;

          // Clear existing pixels
          pixels = [];

          // Collect unique colors in order and groups from imported data
          const colorMap = new Map(); // hex -> index
          const colorList = []; // ordered list of unique colors
          const uniqueGroups = new Set();

          jsonData.Artwork.PixelData.forEach(pd => {
            if (!colorMap.has(pd.ColorHex)) {
              colorMap.set(pd.ColorHex, colorList.length);
              colorList.push(pd.ColorHex);
            }
            if (pd.Group && pd.Group !== 0) {
              uniqueGroups.add(pd.Group);
            }
          });

          // Rebuild palette with unique colors in order
          palette = [];
          document.getElementById('palette').innerHTML = '';

          if (jsonData.Palette && Array.isArray(jsonData.Palette)) {
            // Load palette from stored data
            jsonData.Palette.forEach(colorHex => {
              addColor('#' + colorHex);
            });
          } else {
            // Fallback: extract unique colors from pixels (old format)
            colorList.forEach(colorHex => {
              addColor('#' + colorHex);
            });
          }

          // Rebuild data groups
          dataGroups = [{ id: 0, name: 'None' }];
          const sortedGroups = Array.from(uniqueGroups).sort((a, b) => a - b);
          sortedGroups.forEach(groupId => {
            dataGroups.push({ id: groupId, name: `Group ${groupId}` });
          });
          activeDataGroupId = 0;

          // Rebuild color type groups from pixel data
          colorTypeGroups = [];
          const uniqueColorTypes = new Set();
          jsonData.Artwork.PixelData.forEach(pd => {
            if (pd.ColorType && pd.ColorType !== 0) {
              uniqueColorTypes.add(pd.ColorType);
            }
          });

          // Create color type groups based on what's in the data
          uniqueColorTypes.forEach(typeId => {
            // Find a pixel with this color type to get its color
            const samplePixel = jsonData.Artwork.PixelData.find(pd => pd.ColorType === typeId);
            if (samplePixel) {
              colorTypeGroups.push({
                id: typeId,
                color: '#' + samplePixel.ColorHex,
                name: `Type ${typeId}`
              });
            }
          });
          activeColorTypeId = 0;

          // Import pixels with correct color group assignment
          jsonData.Artwork.PixelData.forEach(pd => {
            const hex = '#' + pd.ColorHex;
            const rgb = hexToRgb(hex);

            // Use stored ColorGroup if available, otherwise use colorMap
            let colorGroupIndex = pd.ColorGroup;
            if (colorGroupIndex === undefined || colorGroupIndex === null) {
              colorGroupIndex = colorMap.get(pd.ColorHex);
            }

            pixels.push({
              x: pd.Position.x,
              y: pd.Position.y,
              r: rgb.r,
              g: rgb.g,
              b: rgb.b,
              group: pd.Group || 0,
              colorGroup: colorGroupIndex,
              colorType: pd.ColorType || 0
            });
          });

          // Recreate canvas with proper size
          updateCanvasSize();

          // Create temporary canvas to render the image
          const t = document.createElement('canvas');
          t.width = SIZE;
          t.height = SIZE;
          const tctx = t.getContext('2d');
          const imgData = tctx.createImageData(SIZE, SIZE);
          const data = imgData.data;

          // Fill canvas with imported pixels
          pixels.forEach(p => {
            const i = (p.y * SIZE + p.x) * 4;
            data[i] = p.r;
            data[i + 1] = p.g;
            data[i + 2] = p.b;
            data[i + 3] = 255;
          });

          tctx.putImageData(imgData, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(t, 0, 0, canvas.width, canvas.height);

          // Rebuild groups structure for UI (without reassigning pixels)
          groups = palette.map((p, i) => ({
            index: i,
            color: hexToRgb(p.value),
            pixels: pixels.filter(px => px.colorGroup === i)
          }));

          // Update UI
          renderColorGroups();
          renderColorTypeGroups();
          renderDataGroups();
          renderColorTypeGroups();
          draw();

          // Display in textarea
          document.getElementById('output').value = JSON.stringify(jsonData, null, 2);

          alert(`Successfully imported ${pixels.length} pixels (${SIZE}x${SIZE})\n${colorList.length} colors, ${uniqueGroups.size} groups`);

        } catch (err) {
          alert('Error parsing JSON: ' + err.message);
          console.error(err);
        }
      };
      reader.readAsText(file);

      // Reset input so same file can be imported again
      e.target.value = '';
    };

    /* ================= UTILS ================= */
    function hexToRgb(h) {
      const n = parseInt(h.slice(1), 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
    }

    /* ================= INIT ================= */
    initPalette();
    renderDataGroups();
    renderColorTypeGroups();

    // Toggle hint function
    function toggleHint() {
      const hint = document.querySelector('.hint');
      const content = document.getElementById('hintContent');
      const toggle = document.getElementById('hintToggle');

      if (content.classList.contains('collapsed')) {
        content.classList.remove('collapsed');
        hint.classList.remove('collapsed');
        toggle.textContent = 'üí°';
      } else {
        content.classList.add('collapsed');
        hint.classList.add('collapsed');
        toggle.textContent = 'üí°';
      }
    }

    // Make toggleHint available globally
    window.toggleHint = toggleHint;
  </script>

</body>

</html>